
DESC DEPARTMENTS
DESC EMPLOYEES
-- NOT NULL : *로 MANDATORY 모든 레코드에 데이터를 가지고 있다.
-- NOT NULL표시가 없다면 o (OPTIONALL)
-- NUMBER(N) : 최대 4자리의 숫자 표현
-- VARCHAR2(N) : 문자
-- 대소문자 상관x


-- SELECT 기본 문법
SELECT DEPARTMENT_ID, DEPARTMENT_NAME -- 보고싶은 COLLUM선택 (SELECT절)
FROM DEPARTMENTS;                                              -- 어느 TABLE에서 가져올것인가? (FROM절)
-- 세미콜론은 한 문장이 끝났을때 써줌. 안써줘도 상관은 없지만 표시의 느낌으로

-- * : 모든 데이터
SELECT * FROM departments;

-- ALIAS(별칭) : 컬럼 이름에 별칭 설정하여 임의로 이름변경 (AS를 사용해도됨)
SELECT DEPARTMENT_ID DEPTID, DEPARTMENT_NAME DEPTNAME FROM DEPARTMENTS;
-- 대소문자, 공백 구분을 위해서는 " " 사용
SELECT DEPARTMENT_ID "DEPTid", DEPARTMENT_NAME "DEPT name" FROM DEPARTMENTS;


-- 중복제거
SELECT DISTINCT LOCATION_ID FROM DEPARTMENTS;
SELECT * FROM EMPLOYEES;
-- 두개를 작성하면 두개가 묶여서 DISTINCT 적용
SELECT DISTINCT MANAGER_ID, JOB_ID FROM EMPLOYEES;


-- 산술연산 +-*/
SELECT EMPLOYEE_ID, SALARY, SALARY + 1000 "NEW SAL" FROM EMPLOYEES;
--DUAL : 빈 버퍼의 역할을 해주는 임시 공간 같은 느낌 
SELECT SYSDATE FROM DUAL;
-- DATE에 산술연산(+,-만가능)
SELECT EMPLOYEE_ID, HIRE_DATE, HIRE_DATE+1 "NEW DATE" FROM EMPLOYEES;
SELECT EMPLOYEE_ID, HIRE_DATE, HIRE_DATE-1 "NEW _DATE" FROM EMPLOYEES;
--날짜 포맷설정
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD HH:MI:SS PM') FROM DUAL;
SELECT TO_CHAR(SYSDATE+1, 'YYYY-MM-DD HH:MI:SS PM') FROM DUAL;
SELECT TO_CHAR(SYSDATE+1/24, 'YYYY-MM-DD HH:MI:SS PM') FROM DUAL;

-- || : 합치기   EX) ||'ABC'||    ABC -> 리터럴문자열
SELECT EMPLOYEE_ID, FIRST_NAME||','||LAST_NAME AS "FULL NAME" FROM EMPLOYEES;

SET PAGESIZE 1000
SET LINESIZE 3000
COL LAST_NAME FORMAT A15
COL SALARY FORMAT 999999

-- '를 표시하는 방법들
SELECT 'Mother''s Birthday' DATA_TEXT FROM DUAL;
SELECT Q'[Mother's Birthday]' DATA_TEXT FROM DUAL;
SELECT Q'!Mother's Birthday!' DATA_TEXT FROM DUAL;

--TO_CHAR : 문자열로

-- WHERE 조건
SELECT EMPLOYEE_ID, LAST_NAME
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 90;

SELECT EMPLOYEE_ID, LAST_NAME
FROM EMPLOYEES
WHERE HIRE_DATE >= '2005/01/01';

SELECT EMPLOYEE_ID, LAST_NAME
FROM EMPLOYEES
WHERE HIRE_DATE >= TO_DATE('01-14-2006', 'MM-DD-YYYY');

--원하는 날짜형식으로 보기
SELECT EMPLOYEE_ID, LAST_NAME, TO_CHAR(HIRE_DATE,'MM-DD-YYYY') NEW_HIRE
FROM EMPLOYEES
WHERE HIRE_DATE >= '2005/01/01';

--문자열 대소 비교
SELECT EMPLOYEE_ID, LAST_NAME
FROM EMPLOYEES
WHERE LAST_NAME > 'W';

--BETWEEN AND 사용
SELECT EMPLOYEE_ID, LAST_NAME, HIRE_DATE, SALARY
FROM EMPLOYEES
WHERE SALARY BETWEEN 5000 AND 6000;

--NOT BETWEEN AND
SELECT EMPLOYEE_ID, LAST_NAME, HIRE_DATE, SALARY
FROM EMPLOYEES
WHERE SALARY NOT BETWEEN 5000 AND 6000;

--날짜도 사용가능
SELECT EMPLOYEE_ID, LAST_NAME, TO_CHAR(HIRE_DATE, 'MM-DD-YYYY') NEW_HIRE
FROM EMPLOYEES
WHERE HIRE_DATE NOT BETWEEN TO_DATE('01-14-2006', 'MM-DD-YYYY') AND TO_DATE('01-14-2007', 'MM-DD-YYYY');

--IN(1,2,3) 1,2,3중에 하나가 포함
SELECT EMPLOYEE_ID, LAST_NAME, DEPARTMENT_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID IN(10,20,30);

SELECT EMPLOYEE_ID, LAST_NAME, TO_CHAR(HIRE_DATE, 'MM-DD-YYYY') NEW_HIRE
FROM EMPLOYEES
WHERE HIRE_DATE IN (TO_DATE('01-14-2006', 'MM-DD-YYYY'), TO_DATE('01-14-2007', 'MM-DD-YYYY'));

--문자열을 데이터베이스 내에서 조회할 때 대소문자 구분!! 
SELECT EMPLOYEE_ID, LAST_NAME
FROM EMPLOYEES
WHERE LAST_NAME = 'Vargas';

--LIKE 'V%' : V로시작하는 것들 있어도되고 없어도되고
SELECT EMPLOYEE_ID, LAST_NAME
FROM EMPLOYEES
WHERE LAST_NAME LIKE 'V%';
--LIKE 'V__' : V로시작해서 뒤에 무조건 2개의 아무 문자가 있는 것들
SELECT EMPLOYEE_ID, LAST_NAME
FROM EMPLOYEES
WHERE LAST_NAME LIKE 'V_____';

SELECT EMPLOYEE_ID, LAST_NAME
FROM EMPLOYEES
WHERE LAST_NAME LIKE '_____s';

SELECT EMPLOYEE_ID, LAST_NAME, SALARY
FROM EMPLOYEES
WHERE SALARY LIKE '4___';

SELECT EMPLOYEE_ID, LAST_NAME, HIRE_DATE
FROM EMPLOYEES
WHERE HIRE_DATE LIKE '02/08%';

--LIKE 'W_D%' ESCAPE 'W' : W뒤의 문자자체를 쓸 수 있도록 설정해주는 것 _나 %등 자체를 검색하고 싶을 때!!  ESCAPE 는 LIKE하고만
SELECT EMPLOYEE_ID, JOB_ID
FROM EMPLOYEES
WHERE JOB_ID LIKE 'ACW_%' ESCAPE 'W';

SELECT EMPLOYEE_ID, JOB_ID
FROM EMPLOYEES
WHERE JOB_ID LIKE 'ACW_%' ESCAPE 'W';

SELECT EMPLOYEE_ID, JOB_ID
FROM EMPLOYEES
WHERE JOB_ID LIKE 'ACW__%' ESCAPE 'W';


--NULL 조회 : IS NULL
SELECT  * FROM EMPLOYEES
WHERE COMMISSION_PCT IS NULL;

SELECT  * FROM EMPLOYEES
WHERE COMMISSION_PCT IS NOT NULL AND SALARY > 6000;

--AND, OR  A OR B AND C 이면 (B+C)AND의 조건을 먼저 찾고 그다음 OR의 A를 찾음
-- (A OR B) AND C 이면 A이거나 B인 조건을 찾은 후 동시에 C를 만족하는 것을 찾음

--ORDER BY(ASC,DESC)
SELECT EMPLOYEE_ID, LAST_NAME, DEPARTMENT_ID FROM EMPLOYEES
WHERE DEPARTMENT_ID IN (10,20,30,40)
ORDER BY DEPARTMENT_ID ASC;
--조건이 두개 일때 A ASC, B DESC 이면 A조건을 우선적으로 1차정렬하고 B를 다시 2차정렬
SELECT EMPLOYEE_ID, LAST_NAME, SALARY, DEPARTMENT_ID FROM EMPLOYEES
WHERE DEPARTMENT_ID IN (10,20,30,40)
ORDER BY DEPARTMENT_ID ASC, SALARY DESC;
-- A,B,C DESC : A먼저 정렬,,마지막으로 C가 정렬

SELECT EMPLOYEE_ID, LAST_NAME, SALARY S, DEPARTMENT_ID ID FROM EMPLOYEES
WHERE DEPARTMENT_ID IN (10,20,30,40)
ORDER BY ID ASC, S DESC;

--COLUM순서대로
SELECT EMPLOYEE_ID, DEPARTMENT_ID, JOB_ID, SALARY FROM EMPLOYEES
WHERE DEPARTMENT_ID IN (10,20,30,40)
ORDER BY 2, 3, 4 DESC;

--치환변수
SELECT EMPLOYEE_ID, DEPARTMENT_ID, JOB_ID, SALARY FROM EMPLOYEES
WHERE DEPARTMENT_ID = &1;

SELECT EMPLOYEE_ID &1, DEPARTMENT_ID, JOB_ID, SALARY FROM EMPLOYEES
WHERE DEPARTMENT_ID = &2;

SET ECHO ON --스크립트에서 어떤 SQL을 사용했는지 확인하기 위해
DEFINE B = 'DEPARTMENT_ID' --미리 정의해놓기
UNDEFINE B --정의해지

SELECT DEPARTMENT_ID FROM EMPLOYEES
