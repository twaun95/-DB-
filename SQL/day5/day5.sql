--EQU JOIN : 두 개 이상의 테이블에서 서로 관련이 있는 RECORD들을 하나의 SELECT문으로 묶어서 결과 조회.


--NON EQU JOIN : 두 개 이상의 테이블에서 서로 관련이 있는 RECORD들을 하나의 SELECT문으로 묶어서 결과 조회.
--                  단, 조인식에서 컬럼과 컬럼을 비교할 때 '='를 사용하지 않고 다른 비교 연산자를 사용하는 조인.

DESC JOBS
SELECT * FROM JOBS;

SELECT EMPLOYEE_ID, JOB_ID, SALARY FROM EMPLOYEES WHERE EMPLOYEE_ID=205;

SELECT E.EMPLOYEE_ID, E.LAST_NAME, E.JOB_ID, E.SALARY, J.JOB_ID, J.JOB_TITLE, J.MIN_SALARY, J.MAX_SALARY
FROM EMPLOYEES E, JOBS J
WHERE E.EMPLOYEE_ID=205 AND E.SALARY BETWEEN J.MIN_SALARY AND J.MAX_SALARY;


--SELF JOIN : 하나의 테이블 안에 관련된 RECORD들을 연결해서 하나의 RECORD로 조회

SELECT * FROM EMPLOYEES;

-- 사원 테이블의 각 사원의 사번, LAST_NAME, 매니저사원의 이름, 매니저 사원부서 조회.
 
 --EMPLOYEES 하나의 테이블을 서로 다른 두개의 테이블인 것처럼 보이는 작업.
 --EMPLOYEES MANAGER테이블 : 매니저 역할을 하는 사원 조회
 --EMPLOYEES EMP 테이블 : 부하직원 사원의 정보를 조회.
 
 SELECT MANAGER.EMPLOYEE_ID, MANAGER.LAST_NAME, EMP.EMPLOYEE_ID, EMP.LAST_NAME "MANGER NAME", EMP.MANAGER_ID
 FROM EMPLOYEES MANAGER, EMPLOYEES EMP  
WHERE MANAGER.EMPLOYEE_ID = 103 AND MANAGER.EMPLOYEE_ID = EMP.MANAGER_ID;

SELECT MANAGER.EMPLOYEE_ID, MANAGER.LAST_NAME, EMP.EMPLOYEE_ID, EMP.LAST_NAME, EMP.MANAGER_ID
 FROM EMPLOYEES MANAGER, EMPLOYEES EMP  
WHERE MANAGER.EMPLOYEE_ID = EMP.MANAGER_ID;

--4. OUTER JOIN (EUQ JOIN의 결과를 포함 + 
-- 두 개 이상의 또는 하나의 테이블 안에서 관련성을 가지는 레코드들을 하나의 레코드로 묶어서 조회
-- EUQ JOIN을 하면 조회가 되지 않는 레코드가 있을 수 있다. EX) 

SELECT D.DEPARTMENT_NAME, E.LAST_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID;

SELECT D.DEPARTMENT_NAME, E.LAST_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID(+); -- (+)위치의 반대쪽 테이블의 모든 정보를 읽는다. -->D테이블의 DEPARTMENT_ID를 모두 읽음.

-- 위와 같음.`
SELECT D.DEPARTMENT_NAME, E.LAST_NAME
FROM EMPLOYEES E LEFT OUTER JOIN DEPARTMENTS D
ON (D.DEPARTMENT_ID = E.DEPARTMENT_ID);


SELECT EMPLOYEE_ID, LAST_NAME, DEPARTMENT_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NULL;

SELECT D.DEPARTMENT_NAME, E.LAST_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.EMPLOYEE_ID = 178 AND D.DEPARTMENT_ID = E.DEPARTMENT_ID;

--부서배치가 안되어 있는 사원도 조회가능
SELECT D.DEPARTMENT_NAME, E.LAST_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.EMPLOYEE_ID = 178 AND D.DEPARTMENT_ID(+) = E.DEPARTMENT_ID;



SELECT * FROM DEPARTMENTS;

SELECT D.DEPARTMENT_NAME, D.DEPARTMENT_ID, E.LAST_NAME, E.DEPARTMENT_ID
FROM EMPLOYEES E, DEPARTMENTS D
WHERE D.DEPARTMENT_ID(+) = E.DEPARTMENT_ID;

SELECT D.DEPARTMENT_NAME, D.DEPARTMENT_ID, E.LAST_NAME, E.DEPARTMENT_ID
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID(+); --부서가 배치되어 있지 않은 사원 조회 가능

SELECT D.DEPARTMENT_NAME, D.DEPARTMENT_ID, E.LAST_NAME, E.DEPARTMENT_ID
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID(+) = D.DEPARTMENT_ID; --사원이 배치되어 있지 않은 부서 조회 가능

--조인에 대한 문법에 대해
-- ANSI표준문법 : 1999년에 나온 표준문법, SQL문법을 여러 종류의 데이터베이스에 표준으로 사용할 수 있는 문법을 만든 것.

--지금까지 해왔던것
SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME, D.MANAGER_ID, E.EMPLOYEE_ID, E.LAST_NAME, E.MANAGER_ID, D.DEPARTMENT_ID
FROM DEPARTMENTS D, EMPLOYEES E
WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID AND D.MANAGER_ID = E.MANAGER_ID;

--1.NATURAL JOIN
--두 개의 테이블 사이에 같은 이름을 가지고 있는 컬럼을 이용해서 조인.
-- 주의사항
-- 테이블에 대해서 ALIA(별칭)을 줄 수 없다.
SELECT DEPARTMENT_ID, DEPARTMENT_NAME, MANAGER_ID, EMPLOYEE_ID, LAST_NAME
FROM DEPARTMENTS NATURAL JOIN EMPLOYEES
ORDER BY DEPARTMENT_ID;

--2.USING
--주의사항
-- USING 절 마지막에 ()에 나오는 컬럼은 (DEPARTMENT_ID) ALIAS(별칭)을 사용할 수 없다.
SELECT DEPARTMENT_ID, D.DEPARTMENT_NAME, E.EMPLOYEE_ID, E.LAST_NAME, DEPARTMENT_ID
FROM DEPARTMENTS D JOIN EMPLOYEES E USING (DEPARTMENT_ID);

--2개도 가능.
SELECT DEPARTMENT_ID, D.DEPARTMENT_NAME, E.EMPLOYEE_ID, E.LAST_NAME, DEPARTMENT_ID
FROM DEPARTMENTS D JOIN EMPLOYEES E USING (DEPARTMENT_ID, MANAGER_ID);

-- 위아래가 같은 것
SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME, D.MANAGER_ID, E.EMPLOYEE_ID, E.LAST_NAME, E.MANAGER_ID, D.DEPARTMENT_ID
FROM DEPARTMENTS D, EMPLOYEES E
WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID AND D.MANAGER_ID = E.MANAGER_ID;


--3. ON절을 이용하는 JOIN

SELECT D.DEPARTMENT_NAME, D.DEPARTMENT_ID, E.LAST_NAME, E.DEPARTMENT_ID
FROM EMPLOYEES E JOIN DEPARTMENTS D
ON ( E.DEPARTMENT_ID = D.DEPARTMENT_ID);

SELECT D.DEPARTMENT_NAME, D.DEPARTMENT_ID, E.LAST_NAME, E.DEPARTMENT_ID
FROM EMPLOYEES E JOIN DEPARTMENTS D
ON ( E.DEPARTMENT_ID = D.DEPARTMENT_ID AND E.MANAGER_ID = D.MANAGER_ID);
 
 --4. LEFT OUTER
SELECT D.DEPARTMENT_NAME, E.LAST_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID(+); -- (+)위치의 반대쪽 테이블의 모든 정보를 읽는다. -->D테이블의 DEPARTMENT_ID를 모두 읽음.

 
SELECT D.DEPARTMENT_NAME, E.LAST_NAME
FROM EMPLOYEES E LEFT OUTER JOIN DEPARTMENTS D
ON (D.DEPARTMENT_ID = E.DEPARTMENT_ID);

 --5. RIGHT OUTER
SELECT D.DEPARTMENT_NAME, E.LAST_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE D.DEPARTMENT_ID(+) = E.DEPARTMENT_ID; 

SELECT D.DEPARTMENT_NAME, E.LAST_NAME
FROM EMPLOYEES E RIGHT OUTER JOIN DEPARTMENTS D
ON (D.DEPARTMENT_ID = E.DEPARTMENT_ID);
 
 --6. FULL OUTER JOIN
SELECT D.DEPARTMENT_NAME, E.LAST_NAME
FROM EMPLOYEES E FULL OUTER JOIN DEPARTMENTS D
ON D.DEPARTMENT_ID = E.DEPARTMENT_ID;


