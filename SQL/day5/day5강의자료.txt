--  사원 테이블에서 매니저가 같은 사원들(MANAGER_ID 컬럼을 이용) 중에서 같은 JOB_ID를 가지고 있는 사원들이 
--  총 몇명인지하고 사원들의 급여에 대한 평균값을 조회 (그룹함수 이용)

SELECT MANAGER_ID, JOB_ID, COUNT(*) EMP_CNT, AVG(SALARY) AVGSAL
FROM  EMPLOYEES
GROUP BY MANAGER_ID, JOB_ID
ORDER BY AVGSAL DESC;

SELECT EMPLOYEE_ID,LAST_NAME,SALARY,MANAGER_ID,JOB_ID
FROM EMPLOYEES
WHERE MANAGER_ID=146 AND JOB_ID='SA_REP';

SELECT EMPLOYEE_ID,LAST_NAME,SALARY,MANAGER_ID,JOB_ID
FROM EMPLOYEES
WHERE MANAGER_ID IS NULL AND JOB_ID='AD_PRES';

-- 'Administration'  이름을 가진 부서에서 근무하고 있는 사원들의 급여의 합계를 조회 
--   (DEPARTMENTS 테이블과 EMPLOYEES 테이블사이의 조인과 SUM 그룹함수 이용) 

SELECT DEPARTMENT_ID, DEPARTMENT_NAME
FROM DEPARTMENTS 
WHERE DEPARTMENT_NAME = 'Administration';

SELECT EMPLOYEE_ID, SALARY, DEPARTMENT_ID
FROM EMPLOYEES  WHERE DEPARTMENT_ID=10;

SELECT DEPARTMENT_ID, SUM(SALARY)
FROM EMPLOYEES 
WHERE DEPARTMENT_ID = 10
GROUP BY DEPARTMENT_ID;

-- JOIN을 이용
SELECT D.DEPARTMENT_ID, SUM(SALARY)
FROM DEPARTMENTS D,EMPLOYEES E
WHERE D.DEPARTMENT_NAME = 'Administration' AND D.DEPARTMENT_ID = E.DEPARTMENT_ID
GROUP BY D.DEPARTMENT_ID;

-- 'Seattle'이란 도시(LOCATIONS 테이블에 CITY컬럼에 있는 데이타)
-- 에 근무하고 있는 사원의 번호와 사원의 이름(LAST_NAME)과 부서이름을 조회 (조인 문제)

SELECT *
FROM LOCATIONS  WHERE CITY = 'Seattle';

SELECT * FROM DEPARTMENTS WHERE LOCATION_ID = 1700;

-- SELECT * FROM EMPLOYEES WHERE DEPARTMENT_ID IN (10,30,90,....,270);
SELECT * FROM EMPLOYEES WHERE DEPARTMENT_ID IN (10,30,90);

SET PAGESIZE 1000

SELECT L.CITY, D.DEPARTMENT_NAME, E.EMPLOYEE_ID, E.LAST_NAME, E.DEPARTMENT_ID
FROM LOCATIONS L, DEPARTMENTS D, EMPLOYEES E 
WHERE L.CITY = 'Seattle' AND L.LOCATION_ID = D.LOCATION_ID AND D.DEPARTMENT_ID = E.DEPARTMENT_ID; 

-- 부서의 평균급여가 7000보다 큰 부서의 부서 ID와 해당 부서의 평균급여 조회 (HAVING절을 이용) 

SELECT DEPARTMENT_ID, ROUND(AVG(SALARY),0) AVGSAL
FROM EMPLOYEES 
GROUP BY DEPARTMENT_ID
HAVING AVG(SALARY) > 7000
ORDER BY DEPARTMENT_ID;

SELECT DEPARTMENT_ID, ROUND(AVG(SALARY),0) AVGSAL
FROM EMPLOYEES 
GROUP BY DEPARTMENT_ID
HAVING ROUND(AVG(SALARY),0) > 7000
ORDER BY DEPARTMENT_ID;

SELECT DEPARTMENT_ID, ROUND(AVG(SALARY),0) AVGSAL
FROM EMPLOYEES 
GROUP BY DEPARTMENT_ID
HAVING AVGSAL > 7000  (X)   -- HAVING절에는 ALIAS(컬럼에 대한 별칭)를 사용할 수 없다.
ORDER BY DEPARTMENT_ID;

SELECT DEPARTMENT_ID, ROUND(AVG(SALARY),0) AVGSAL
FROM EMPLOYEES 
GROUP BY DEPARTMENT_ID
HAVING AVG(SALARY) > 7000
ORDER BY ROUND(AVG(SALARY),0) DESC;

SELECT DEPARTMENT_ID, ROUND(AVG(SALARY),0) AVGSAL
FROM EMPLOYEES 
GROUP BY DEPARTMENT_ID
HAVING AVG(SALARY) > 7000
ORDER BY AVGSAL DESC;


SELECT manager_id, MIN(salary)
FROM employees
WHERE manager_id IS NOT NULL
GROUP BY manager_id
HAVING MIN(salary) > 6000
ORDER BY MIN(salary) DESC;

SELECT EMPLOYEE_ID,LAST_NAME,SALARY, MANAGER_ID FROM EMPLOYEES WHERE MANAGER_ID=146;

SELECT COUNT(*) total,
SUM(DECODE(TO_CHAR(hire_date, 'YYYY'),2005,1,0))"2005",
SUM(DECODE(TO_CHAR(hire_date, 'YYYY'),2006,1,0))"2006",
SUM(DECODE(TO_CHAR(hire_date, 'YYYY'),2007,1,0))"2007",
SUM(DECODE(TO_CHAR(hire_date, 'YYYY'),2008,1,0))"2008",
SUM(CASE WHEN TO_CHAR(hire_date, 'YYYY') NOT BETWEEN '2005' AND '2008' THEN 1 ELSE 0 END) "OTHERS"
FROM employees;

SELECT EMPLOYEE_ID,HIRE_DATE, TO_CHAR(HIRE_DATE,'YYYY-MM-DD') NEW_DATE FROM EMPLOYEES;
SELECT EMPLOYEE_ID,HIRE_DATE, TO_CHAR(hire_date, 'YYYY') NEW_DATE FROM EMPLOYEES;
-- DECODE
SELECT EMPLOYEE_ID, SALARY, DEPARTMENT_ID, DECODE(DEPARTMENT_ID,10,SALARY*2,20,SALARY*3,30,SALARY*4,SALARY) NEW_SAL
FROM EMPLOYEES 
WHERE DEPARTMENT_ID IN (10,20,30,40);

SELECT EMPLOYEE_ID, HIRE_DATE, TO_CHAR(hire_date, 'YYYY'),  DECODE(TO_CHAR(hire_date, 'YYYY'),2005,1,0) NEW_COL
FROM EMPLOYEES;

SELECT SUM(DECODE(TO_CHAR(hire_date, 'YYYY'),2005,1,0)) "2005",
       SUM(DECODE(TO_CHAR(hire_date, 'YYYY'),2003,1,0)) "2003"
FROM EMPLOYEES; 

SELECT COUNT(*) FROM EMPLOYEES WHERE TO_CHAR(hire_date, 'YYYY') = '2003';

SELECT DEPARTMENT_ID,COUNT(*) total,
SUM(DECODE(TO_CHAR(hire_date, 'YYYY'),2005,1,0))"2005",
SUM(DECODE(TO_CHAR(hire_date, 'YYYY'),2006,1,0))"2006",
SUM(DECODE(TO_CHAR(hire_date, 'YYYY'),2007,1,0))"2007",
SUM(DECODE(TO_CHAR(hire_date, 'YYYY'),2008,1,0))"2008",
SUM(CASE WHEN TO_CHAR(hire_date, 'YYYY') NOT BETWEEN '2005' AND '2008' THEN 1 ELSE 0 END) "OTHERS"
FROM employees
GROUP BY DEPARTMENT_ID
ORDER BY DEPARTMENT_ID;

-- 입사년도가 2005 ~ 2008 사이에 입사한 사원 수 
SELECT SUM(CASE WHEN TO_CHAR(hire_date, 'YYYY') BETWEEN '2005' AND '2008' THEN 1 ELSE 0 END) COUNT_YEAR
FROM employees;

-- 입사년도가 2005 ~ 2008 사이에 입사하지 않은 사원 수 
SELECT SUM(CASE WHEN TO_CHAR(hire_date, 'YYYY') NOT BETWEEN '2005' AND '2008' THEN 1 ELSE 0 END) COUNT_YEAR
FROM employees;


-- 1. EQU JOIN : 두 개이상의 테이블에서 서로 관련이 있는 RECORD들을 하나의 SELECT문으로 묶어서 결과 조회

SELECT D.DEPARTMENT_NAME,D.DEPARTMENT_ID, E.EMPLOYEE_ID, E.LAST_NAME, E.DEPARTMENT_ID
FROM DEPARTMENTS D,EMPLOYEES E
WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID; -- (조인식(조인조건) : 두 개의 테이블에서 서로 관련되는 데이타를 가지고 있는 컬럼들을 비교)

-- 2. NON EQU JOIN : 두 개이상의 테이블에서 서로 관련이 있는 RECORD들을 하나의 SELECT문으로 묶어서 결과 조회
--                단, 조인식에서 컬럼과 컬럼을 비교할 때 "="를 사용하지 않고 다른 비교 연산자를 사용하는 조인.

DESC JOBS
SELECT * FROM JOBS;

SELECT EMPLOYEE_ID,JOB_ID,SALARY FROM EMPLOYEES WHERE EMPLOYEE_ID=205;

SELECT E.EMPLOYEE_ID, E.LAST_NAME, E.JOB_ID, E.SALARY, J.JOB_ID, J.JOB_TITLE, J.MIN_SALARY, J.MAX_SALARY
FROM EMPLOYEES E, JOBS J
WHERE E.EMPLOYEE_ID=205 AND E.SALARY BETWEEN J.MIN_SALARY AND J.MAX_SALARY;

-- 3. SELF JOIN : 하나의 테이블 안에 관련된 RECORD들을 연결해서 하나의 RECORD로 조회 
COL FIRST_NAME FORMAT A15
COL LAST_NAME FORMAT A15
COL EMAIL FORMAT A10
SELECT * FROM EMPLOYEES;

-- 사원 테이블의 각 사원의 사번, LAST NAME, 매니저사원의 이름, 매니저사원부서 조회
-- EMPLOYEES 테이블을 2개의 서로 다른 테이블인 것처럼 보이는 작업
-- EMPLOYEES MANAGER 테이블의 경우는 매니저 역할을 하는 사원 조회하는 테이블 
-- EMPLOYEES EMP 테이블의 경우는 부하직원 사원의 정보를 조회하는 테이블 

SELECT MANAGER.EMPLOYEE_ID "MANAGER ID",MANAGER.LAST_NAME "Manager Name", 
        EMP.EMPLOYEE_ID, EMP.LAST_NAME, EMP.MANAGER_ID
FROM EMPLOYEES MANAGER, EMPLOYEES EMP              
WHERE MANAGER.EMPLOYEE_ID = EMP.MANAGER_ID AND MANAGER.EMPLOYEE_ID = 103;       

SELECT MANAGER.EMPLOYEE_ID "MANAGER ID",MANAGER.LAST_NAME "Manager Name", 
        EMP.EMPLOYEE_ID, EMP.LAST_NAME, EMP.MANAGER_ID
FROM EMPLOYEES MANAGER, EMPLOYEES EMP              
WHERE MANAGER.EMPLOYEE_ID = EMP.MANAGER_ID; 


-- 4. OUTER JOIN (EUQ JOIN의 결과를 포함 + 
-- 두 개이상의 또는 하나의 테이블 안에서 관련성을 가지는 레코드들을 하나의 레코드로 묶어서 조회(EQU JOIN) + 
-- EQU JOIN을 하면 조회가 되지 않는 레코드가 있을 수 있다 예를 들면 
SELECT EMPLOYEE_ID,LAST_NAME,DEPARTMENT_ID
FROM EMPLOYEES 
WHERE DEPARTMENT_ID IS NULL;

SELECT D.DEPARTMENT_NAME,D.DEPARTMENT_ID, E.EMPLOYEE_ID, E.LAST_NAME, E.DEPARTMENT_ID
FROM DEPARTMENTS D,EMPLOYEES E
WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID AND E.EMPLOYEE_ID=178;  -- 일반적인 EQU JOIN시에는 부서배치가 안되어 있는 사원은 조회안됨

SELECT D.DEPARTMENT_NAME,D.DEPARTMENT_ID, E.EMPLOYEE_ID, E.LAST_NAME, E.DEPARTMENT_ID
FROM DEPARTMENTS D,EMPLOYEES E
WHERE D.DEPARTMENT_ID(+) = E.DEPARTMENT_ID AND E.EMPLOYEE_ID=178; -- 부서배치가 안되어 있는 사원도 조회가 됨

SELECT D.DEPARTMENT_NAME,D.DEPARTMENT_ID, E.EMPLOYEE_ID, E.LAST_NAME, E.DEPARTMENT_ID
FROM DEPARTMENTS D,EMPLOYEES E
WHERE D.DEPARTMENT_ID(+) = E.DEPARTMENT_ID; -- 기본적으로 EQU JOIN하면서 추가적으로 부서배치가 안되어 있는 사원 조회

SELECT DISTINCT DEPARTMENT_ID FROM EMPLOYEES ORDER BY DEPARTMENT_ID;  -- 사원이 한명이라도 배치되어 있는 부서 조회
SELECT DISTINCT DEPARTMENT_ID FROM DEPARTMENTS;

SELECT D.DEPARTMENT_NAME,D.DEPARTMENT_ID, E.EMPLOYEE_ID, E.LAST_NAME, E.DEPARTMENT_ID
FROM DEPARTMENTS D,EMPLOYEES E
WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID; 

SELECT D.DEPARTMENT_NAME,D.DEPARTMENT_ID, E.EMPLOYEE_ID, E.LAST_NAME, E.DEPARTMENT_ID
FROM DEPARTMENTS D,EMPLOYEES E
WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID(+); -- 사원이 배치되어 있지 않은 부서도 조회가 가능 


-- ANSI표준문법을 이용한 조인에 대해서
-- ANSI 표준 문법 : 1999년에 나온 표준문법, SQL문법을 여러 종류의 데이타베이스에 표준으로 사용할 수 있는 문법 만든 것.
-- 예전에는 데이타베이스의 종류 (MYSQL, ORACLE, IBM ....)마다 SQL 조인 문법이 서로 다른 문법을 사용했었다 
-- 1999년에 ANSI 표준문법을 만들면서 여러 종류의 데이타베이스에 표준으로 사용할 수 있는 문법 만들게 되었다 

-- 1. NATURAL JOIN 
-- : 두개 이상의 또는 한 개의 테이블안에서 조인을 할 때 이름이 같은 컬럼을 찾아서 자동으로 조인을 하는 방법 
SELECT DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,EMPLOYEE_ID,LAST_NAME
FROM DEPARTMENTS NATURAL JOIN EMPLOYEES  -- 두 개의 테이블 사이에 같은 이름을 가지고 있는 컬럼을 이용해서 조인 
ORDER BY DEPARTMENT_ID;

SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME, D.MANAGER_ID, E.EMPLOYEE_ID, E.LAST_NAME, E.MANAGER_ID, D.DEPARTMENT_ID
FROM DEPARTMENTS D, EMPLOYEES E 
WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID AND D.MANAGER_ID = E.MANAGER_ID;

DESC DEPARTMENTS
DESC EMPLOYEES

-- NATURAL JOIN시 사용시 주의사항 
-- NATURAL JOIN할때는 테이블에 대해 ALIAS(별칭)를 줄 수 없다. 아래와 같이 하면 ERROR 발생
SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME, D.MANAGER_ID, E.EMPLOYEE_ID, E.LAST_NAME
FROM DEPARTMENTS D NATURAL JOIN EMPLOYEES E
ORDER BY D.DEPARTMENT_ID;

-- 2. USING을 이용한 조인 방법 
-- USING절에 나오는 컬럼(DEPARTMENT_ID)은 테이블 별칭을 같이 사용하면 안된다.
-- USING절에 두 개의 테이블에서 조인하는 데 사용하는 컬럼을 정의해서 사용
SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME, E.EMPLOYEE_ID, E.LAST_NAME, E.DEPARTMENT_ID
FROM DEPARTMENTS D JOIN EMPLOYEES E USING (D.DEPARTMENT_ID);  --(X)

SELECT DEPARTMENT_ID, D.DEPARTMENT_NAME, E.EMPLOYEE_ID, E.LAST_NAME
FROM DEPARTMENTS D JOIN EMPLOYEES E USING (DEPARTMENT_ID);  --(O)

SELECT D.DEPARTMENT_NAME,D.DEPARTMENT_ID, E.EMPLOYEE_ID, E.LAST_NAME, E.DEPARTMENT_ID
FROM DEPARTMENTS D,EMPLOYEES E
WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID; 

SELECT DEPARTMENT_ID, D.DEPARTMENT_NAME, MANAGER_ID, E.EMPLOYEE_ID, E.LAST_NAME
FROM DEPARTMENTS D JOIN EMPLOYEES E USING (DEPARTMENT_ID, MANAGER_ID);  --(O)

SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME, D.MANAGER_ID, E.EMPLOYEE_ID, E.LAST_NAME, E.MANAGER_ID, D.DEPARTMENT_ID
FROM DEPARTMENTS D, EMPLOYEES E 
WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID AND D.MANAGER_ID = E.MANAGER_ID;


-- 3. ON 절을 이용하는 조인
SELECT D.DEPARTMENT_NAME,D.DEPARTMENT_ID, E.EMPLOYEE_ID, E.LAST_NAME, E.DEPARTMENT_ID
FROM DEPARTMENTS D JOIN EMPLOYEES E
ON (D.DEPARTMENT_ID = E.DEPARTMENT_ID); 

SELECT D.DEPARTMENT_NAME,D.DEPARTMENT_ID, E.EMPLOYEE_ID, E.LAST_NAME, E.DEPARTMENT_ID
FROM DEPARTMENTS D,EMPLOYEES E
WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID; 

SELECT D.DEPARTMENT_NAME,D.DEPARTMENT_ID, E.EMPLOYEE_ID, E.LAST_NAME, E.DEPARTMENT_ID
FROM DEPARTMENTS D JOIN EMPLOYEES E
ON (D.DEPARTMENT_ID = E.DEPARTMENT_ID AND D.MANAGER_ID = E.MANAGER_ID); 

SELECT D.DEPARTMENT_NAME,D.DEPARTMENT_ID, E.EMPLOYEE_ID, E.LAST_NAME, E.DEPARTMENT_ID
FROM DEPARTMENTS D JOIN EMPLOYEES E
ON D.DEPARTMENT_ID = E.DEPARTMENT_ID AND D.MANAGER_ID = E.MANAGER_ID; 

SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME, D.MANAGER_ID, E.EMPLOYEE_ID, E.LAST_NAME, E.MANAGER_ID, D.DEPARTMENT_ID
FROM DEPARTMENTS D, EMPLOYEES E 
WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID AND D.MANAGER_ID = E.MANAGER_ID;

SELECT MANAGER.EMPLOYEE_ID "MANAGER ID",MANAGER.LAST_NAME "Manager Name", 
        EMP.EMPLOYEE_ID, EMP.LAST_NAME, EMP.MANAGER_ID
FROM EMPLOYEES MANAGER, EMPLOYEES EMP              
WHERE MANAGER.EMPLOYEE_ID = EMP.MANAGER_ID AND MANAGER.EMPLOYEE_ID = 103; 

SELECT MANAGER.EMPLOYEE_ID "MANAGER ID",MANAGER.LAST_NAME "Manager Name", 
        EMP.EMPLOYEE_ID, EMP.LAST_NAME, EMP.MANAGER_ID
FROM EMPLOYEES MANAGER JOIN EMPLOYEES EMP              
ON (MANAGER.EMPLOYEE_ID = EMP.MANAGER_ID AND MANAGER.EMPLOYEE_ID = 103);

SELECT MANAGER.EMPLOYEE_ID "MANAGER ID",MANAGER.LAST_NAME "Manager Name", 
        EMP.EMPLOYEE_ID, EMP.LAST_NAME, EMP.MANAGER_ID
FROM EMPLOYEES MANAGER JOIN EMPLOYEES EMP              
ON (MANAGER.EMPLOYEE_ID = EMP.MANAGER_ID)
AND MANAGER.EMPLOYEE_ID = 103;

SELECT MANAGER.EMPLOYEE_ID "MANAGER ID",MANAGER.LAST_NAME "Manager Name", 
        EMP.EMPLOYEE_ID, EMP.LAST_NAME, EMP.MANAGER_ID
FROM EMPLOYEES MANAGER JOIN EMPLOYEES EMP              
ON (MANAGER.EMPLOYEE_ID = EMP.MANAGER_ID)
WHERE MANAGER.EMPLOYEE_ID = 103;

-- 4. LEFT OUTER JOIN 
SELECT D.DEPARTMENT_NAME,D.DEPARTMENT_ID, E.EMPLOYEE_ID, E.LAST_NAME, E.DEPARTMENT_ID
FROM DEPARTMENTS D, EMPLOYEES E
WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID(+); -- 사원이 배치되어 있지 않은 부서도 조회가 가능 

SELECT D.DEPARTMENT_NAME,D.DEPARTMENT_ID, E.EMPLOYEE_ID, E.LAST_NAME, E.DEPARTMENT_ID
FROM DEPARTMENTS D LEFT OUTER JOIN EMPLOYEES E 
ON (D.DEPARTMENT_ID = E.DEPARTMENT_ID);

-- 5. RIGHT OUTER JOIN 
SELECT D.DEPARTMENT_NAME,D.DEPARTMENT_ID, E.EMPLOYEE_ID, E.LAST_NAME, E.DEPARTMENT_ID
FROM DEPARTMENTS D,EMPLOYEES E
WHERE D.DEPARTMENT_ID(+) = E.DEPARTMENT_ID;  -- 부서배치가 안되어 있는 사원도 조회가 됨

SELECT D.DEPARTMENT_NAME,D.DEPARTMENT_ID, E.EMPLOYEE_ID, E.LAST_NAME, E.DEPARTMENT_ID
FROM DEPARTMENTS D RIGHT OUTER JOIN EMPLOYEES E
ON D.DEPARTMENT_ID = E.DEPARTMENT_ID;  

-- 6. FULL OUTER JOIN 
-- 사원이 배치되어 있지 않은 부서와 부서배치가 안되어 있는 사원 모두를 같이 조회
SELECT D.DEPARTMENT_NAME,D.DEPARTMENT_ID, E.EMPLOYEE_ID, E.LAST_NAME, E.DEPARTMENT_ID
FROM DEPARTMENTS D,EMPLOYEES E
WHERE D.DEPARTMENT_ID(+) = E.DEPARTMENT_ID(+);  (X) 

SELECT D.DEPARTMENT_NAME,D.DEPARTMENT_ID, E.EMPLOYEE_ID, E.LAST_NAME, E.DEPARTMENT_ID
FROM DEPARTMENTS D FULL OUTER JOIN EMPLOYEES E
ON D.DEPARTMENT_ID = E.DEPARTMENT_ID;
















