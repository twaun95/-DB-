--1. 40번 부서의 매니저를 직속상관 매니저로 가지고 있는 사원들의 이름과 소속 부서번호와 소속된 부서이름과 
--   직속상관이 속해있는 부서이름과 직속상관의 사번과 이름(LAST_NAME)을 조회.(SELF JOIN)

--> 40번 해당하는 결과가 나오는 것이 없어서 60번 부서로 결과 나오게 했습니다.
SELECT EMP.LAST_NAME EMP_NAME, EMP.DEPARTMENT_ID EMP_ID, D.DEPARTMENT_NAME EMP_DEPARTNAME, 
D.DEPARTMENT_NAME MANAGER_DEPARTNAME, MANAGER.EMPLOYEE_ID MANAGER_ID, MANAGER.LAST_NAME MANAGER_NAME
FROM EMPLOYEES MANAGER, EMPLOYEES EMP, DEPARTMENTS D
WHERE MANAGER.DEPARTMENT_ID = 60 AND EMP.MANAGER_ID = MANAGER.EMPLOYEE_ID
AND MANAGER.DEPARTMENT_ID = D.DEPARTMENT_ID;

--2. 평균 급여가 7000 이상이 되는 부서에 소속이 되어 있는 사원들의 사번과 사원이름과 급여와 부서이름을 조회.
--(GROUP BY절 + 평균급여, DEPARTMENT TABLE과 EMPLOYEES TABLE을 JOIN - EQU JOIN)

SELECT E.DEPARTMENT_ID, E.LAST_NAME, E.SALARY, D.DEPARTMENT_NAME, ROUND(AVG(E.SALARY),0) AVGSAL
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
GROUP BY E.DEPARTMENT_ID, E.LAST_NAME, E.SALARY,D.DEPARTMENT_NAME
HAVING ROUND(AVG(E.SALARY),0) > 7000
ORDER BY E.DEPARTMENT_ID;


--3. JOB_ID가 'IT_PROG'인 사원들이 받을 수 있는 최소 급여와 최대급여 사이의 급여를 받고 있는 사원의 이름과
--   급여정보를 조회. (EMPLOYEES TABLE과 JOBS TABLE을 이용한 NON-EQU JOIN)

SELECT E.LAST_NAME,  E.SALARY
FROM EMPLOYEES E, JOBS J
WHERE J.JOB_ID='IT_PROG' AND E.SALARY BETWEEN J.MIN_SALARY AND J.MAX_SALARY;

--4.  ON 절을 이용하는 조인방법을 이용해서 입사년도가 2005년보다 늦게 입사한 사원들에 대해서 
--    사원이름, 급여, 사원이 속해있는 부서이름, 입사일자를 조회.

SELECT E.LAST_NAME, E.SALARY, D.DEPARTMENT_NAME, E.HIRE_DATE
FROM EMPLOYEES E  JOIN DEPARTMENTS D
ON D.DEPARTMENT_ID = E.DEPARTMENT_ID AND E.HIRE_DATE > TO_DATE('2005', 'YYYY');