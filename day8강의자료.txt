-- ORDERS TABLE 생성작업 

CREATE TABLE ORDERS 
(ORDER_ID  NUMBER(10) CONSTRAINT ORDERS_ORDER_ID_PK  PRIMARY KEY,
 ORDER_DATE DATE,CUSTOMER_NAME  VARCHAR2(20) CONSTRAINT ORDERS_CUSTOMER_NAME_NN NOT NULL,
 PAYMENT_TYPE  VARCHAR2(10) CONSTRAINT ORDERS_PAYMENT_TYPE_CK  CHECK (PAYMENT_TYPE IN ('CREDIT','CASH')),
 DELIEVERY_METHOD  VARCHAR2(20), ADDRESS  VARCHAR2(20), TOTAL_PRICE  NUMBER(20));

DROP TABLE ORDERS; 

CREATE TABLE ORDERS 
(ORDER_ID  NUMBER(10),ORDER_DATE DATE,CUSTOMER_NAME  VARCHAR2(20) CONSTRAINT ORDERS_CUSTOMER_NAME_NN NOT NULL,
 PAYMENT_TYPE  VARCHAR2(10),
 DELIEVERY_METHOD  VARCHAR2(20), ADDRESS  VARCHAR2(20), TOTAL_PRICE  NUMBER(20),
 CONSTRAINT ORDERS_ORDER_ID_PK  PRIMARY KEY(ORDER_ID),
 CONSTRAINT ORDERS_PAYMENT_TYPE_CK  CHECK (PAYMENT_TYPE IN ('CREDIT','CASH')) );

 DROP TABLE ORDERS; 
 
CREATE TABLE ORDERS 
(ORDER_ID  NUMBER(10),ORDER_DATE DATE,CUSTOMER_NAME  VARCHAR2(20),
 PAYMENT_TYPE  VARCHAR2(10), DELIEVERY_METHOD  VARCHAR2(20), ADDRESS  VARCHAR2(20), TOTAL_PRICE  NUMBER(20));

ALTER TABLE ORDERS 
ADD CONSTRAINT ORDERS_ORDER_ID_PK  PRIMARY KEY(ORDER_ID);

ALTER TABLE ORDERS 
ADD CONSTRAINT ORDERS_PAYMENT_TYPE_CK  CHECK (PAYMENT_TYPE IN ('CREDIT','CASH'));

ALTER TABLE ORDERS 
ADD CONSTRAINT CONSTRAINT ORDERS_CUSTOMER_NAME_NN NOT NULL(CUSTOMER_NAME);  (X)

ALTER TABLE ORDERS
MODIFY (CUSTOMER_NAME  VARCHAR2(20) CONSTRAINT ORDERS_CUSTOMER_NAME_NN NOT NULL); (O)

-- ORDER_ITEMS 테이블 생성 
CREATE TABLE ORDER_ITEMS 
(ITEM_ID  NUMBER(10) CONSTRAINT ORDER_ITEMS_ITEM_ID_PK PRIMARY KEY,
 ITEM_NAME VARCHAR2(20), ITEM_DESC VARCHAR2(30), ITEM_SIZE NUMBER(10),
 ITEM_PRICE  NUMBER(20) CONSTRAINT ORDER_ITEMS_ITEM_PRICE CHECK (ITEM_PRICE BETWEEN 100 AND 300), 
 EXPIRE_DATE DATE CONSTRAINT ORDER_ITEMS_EXPIRE_DATE_NN NOT NULL,
 INVENTORY  NUMBER(10), ORDER_ID NUMBER(10) CONSTRAINT ORDER_ITEMS_ORDER_ID REFERENCES ORDERS(ORDER_ID));
 
DROP TABLE ORDER_ITEMS;

CREATE TABLE ORDER_ITEMS 
(ITEM_ID  NUMBER(10),ITEM_NAME VARCHAR2(20), ITEM_DESC VARCHAR2(30), ITEM_SIZE NUMBER(10),
 ITEM_PRICE  NUMBER(20),EXPIRE_DATE DATE CONSTRAINT ORDER_ITEMS_EXPIRE_DATE_NN NOT NULL,
 INVENTORY  NUMBER(10), ORDER_ID NUMBER(10),
 CONSTRAINT ORDER_ITEMS_ITEM_ID_PK PRIMARY KEY(ITEM_ID),
 CONSTRAINT ORDER_ITEMS_ITEM_PRICE CHECK (ITEM_PRICE BETWEEN 100 AND 300),
 CONSTRAINT ORDER_ITEMS_ORDER_ID FOREIGN KEY(ORDER_ID) REFERENCES ORDERS(ORDER_ID));
 
 DROP TABLE ORDER_ITEMS;
 
 CREATE TABLE ORDER_ITEMS 
(ITEM_ID  NUMBER(10),ITEM_NAME VARCHAR2(20), ITEM_DESC VARCHAR2(30), ITEM_SIZE NUMBER(10),
 ITEM_PRICE  NUMBER(20),EXPIRE_DATE DATE, INVENTORY  NUMBER(10), ORDER_ID NUMBER(10));
 
ALTER TABLE ORDER_ITEMS
ADD CONSTRAINT ORDERS_ITEM_ID_PK  PRIMARY KEY(ITEM_ID);

ALTER TABLE ORDER_ITEMS 
DROP CONSTRAINT ORDERS_ITEM_ID_PK;

ALTER TABLE ORDER_ITEMS
ADD CONSTRAINT ORDER_ITEMS_ITEM_ID_PK  PRIMARY KEY(ITEM_ID);

ALTER TABLE ORDER_ITEMS 
ADD CONSTRAINT ORDER_ITEMS_ITEM_PRICE_CK  CHECK (ITEM_PRICE BETWEEN 100 AND 300);

ALTER TABLE ORDER_ITEMS 
MODIFY (EXPIRE_DATE DATE CONSTRAINT ORDER_ITEMS_EXPIRE_DATE_NN NOT NULL);

ALTER TABLE ORDER_ITEMS
ADD CONSTRAINT ORDER_ITEMS_ORDER_ID FOREIGN KEY(ORDER_ID) REFERENCES ORDERS(ORDER_ID);


-- subquery를 사용하여 테이블 생성
-- 30번 부서 혹은 50번부서의 사원들 정보를 COPY해서 SAMPLE_SUB 테이블을 생성
CREATE TABLE SAMPLE_SUB
AS SELECT EMPLOYEE_ID,LAST_NAME,SALARY,DEPARTMENT_ID 
   FROM EMPLOYEES WHERE DEPARTMENT_ID IN (30,50);

SET PAGESIZE 1000
SET LINESIZE 1000
DESC SAMPLE_SUB   
SELECT * FROM SAMPLE_SUB;

DROP TABLE SAMPLE_SUB;

CREATE TABLE SAMPLE_SUB
AS SELECT EMPLOYEE_ID EMPID,LAST_NAME NAME,SALARY SAL,DEPARTMENT_ID DEPTID 
   FROM EMPLOYEES WHERE DEPARTMENT_ID = 30;

DESC SAMPLE_SUB
SELECT * FROM SAMPLE_SUB;

DROP TABLE SAMPLE_SUB;

CREATE TABLE SAMPLE_SUB
AS SELECT EMPLOYEE_ID EMPID,LAST_NAME||','||FIRST_NAME NAME,SALARY*12 SAL,DEPARTMENT_ID DEPTID 
   FROM EMPLOYEES WHERE DEPARTMENT_ID = 30;

DESC SAMPLE_SUB
SELECT * FROM SAMPLE_SUB;

DROP TABLE SAMPLE_SUB;

CREATE TABLE SAMPLE_SUB
AS SELECT D.DEPARTMENT_NAME, E.EMPLOYEE_ID, E.LAST_NAME, E.DEPARTMENT_ID
   FROM DEPARTMENTS D, EMPLOYEES E
   WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID AND D.DEPARTMENT_ID=30;

DESC SAMPLE_SUB
SELECT * FROM SAMPLE_SUB;

DROP TABLE SAMPLE_SUB;

CREATE TABLE SAMPLE_SUB
AS SELECT * FROM EMPLOYEES WHERE 1=3;  -- EMPLOYEES 테이블의 컬럼의 구조만 COPY하고 데이타는 COPY하지 않겠다.
                                        -- WHERE 절에 나오는 조건이 FALSE가 되면 데이타를 COPY하지 않게 된다.
DESC SAMPLE_SUB
SELECT * FROM SAMPLE_SUB;


-- TRANSACTION 

SELECT EMPLOYEE_ID, LAST_NAME, SALARY FROM EMPLOYEES
WHERE EMPLOYEE_ID = 200;

UPDATE EMPLOYEES SET SALARY = 5000 WHERE EMPLOYEE_ID=200;  -- 하나의 트랜잭션

SELECT EMPLOYEE_ID, LAST_NAME, SALARY FROM EMPLOYEES
WHERE EMPLOYEE_ID = 200;

COMMIT;  -- 위의 업데이트 한 내용을 데이타베이스에 저장해 주겠다.

SELECT EMPLOYEE_ID, LAST_NAME, SALARY FROM EMPLOYEES
WHERE EMPLOYEE_ID = 200;

-- 30번 부서의 사원정보를 COPY해서 SAMPLE_TRAN이라는 TABLE을 생성 
CREATE TABLE SAMPLE_TRAN
AS SELECT EMPLOYEE_ID, LAST_NAME, SALARY, DEPARTMENT_ID
   FROM EMPLOYEES WHERE DEPARTMENT_ID = 30;

SELECT * FROM SAMPLE_TRAN;

-- TRANSACTION 시작
UPDATE SAMPLE_TRAN SET SALARY= 7000 WHERE EMPLOYEE_ID=114;
SELECT * FROM SAMPLE_TRAN WHERE EMPLOYEE_ID=114;
COMMIT; -- UPDATE한 내용이 DB에 저장  -- TRANSACTION 종료 

-- TRANSACTION 시작
UPDATE SAMPLE_TRAN SET SALARY = 9000 WHERE EMPLOYEE_ID=114;
SELECT * FROM SAMPLE_TRAN WHERE EMPLOYEE_ID=114;
UPDATE SAMPLE_TRAN SET SALARY=10000 WHERE EMPLOYEE_ID=115;
SELECT * FROM SAMPLE_TRAN WHERE EMPLOYEE_ID IN (114,115);
COMMIT;  -- UPDATE한 내용들이 DB에 저장  -- TRANSACTION 종료


-- TRANSACTION 시작
UPDATE SAMPLE_TRAN SET SALARY = 4000 WHERE EMPLOYEE_ID=114;
UPDATE SAMPLE_TRAN SET SALARY = 2000 WHERE EMPLOYEE_ID=115;
SELECT * FROM SAMPLE_TRAN WHERE EMPLOYEE_ID IN (114,115);
ROLLBACK;  -- UPDATE한 내용들을 취소  -- TRANSACTION 종료
SELECT * FROM SAMPLE_TRAN WHERE EMPLOYEE_ID IN (114,115);

DESC SAMPLE_TRAN
-- TRANSACTION 시작
INSERT INTO SAMPLE_TRAN (EMPLOYEE_ID,LAST_NAME,SALARY,DEPARTMENT_ID)
VALUES (120,'KIM',3000,30);
INSERT INTO SAMPLE_TRAN 
VALUES (121,'LEE',5000,30);
INSERT INTO SAMPLE_TRAN (EMPLOYEE_ID,LAST_NAME,SALARY,DEPARTMENT_ID)
VALUES (122,'PARK',7000,NULL);
INSERT INTO SAMPLE_TRAN (EMPLOYEE_ID,LAST_NAME,SALARY,DEPARTMENT_ID)
VALUES (123,'OH',NULL,NULL);
INSERT INTO SAMPLE_TRAN 
VALUES (124,'SIM',NULL,NULL);
INSERT INTO SAMPLE_TRAN (EMPLOYEE_ID,LAST_NAME)
VALUES (125,'JU');
SELECT * FROM SAMPLE_TRAN;
COMMIT;  -- UPDATE한 내용들이 DB에 저장  -- TRANSACTION 종료


-- TRANSACTION 시작
UPDATE SAMPLE_TRAN SET SALARY=8888,DEPARTMENT_ID=20 WHERE EMPLOYEE_ID IN (123,124);
UPDATE SAMPLE_TRAN SET SALARY=NULL,DEPARTMENT_ID=NULL WHERE EMPLOYEE_ID = 124;
COMMIT;  -- UPDATE한 내용들이 DB에 저장  -- TRANSACTION 종료

-- TRANSACTION 시작
DELETE FROM SAMPLE_TRAN WHERE EMPLOYEE_ID IN (122,124,125);
SELECT * FROM SAMPLE_TRAN;
COMMIT;  -- UPDATE한 내용들이 DB에 저장  -- TRANSACTION 종료
ROLLBACK; -- 위의 COMMIT한 내용은 취소가 되지 않는다.

-- DEFAULT SYSDATE 라는 것은 HIREDATE 컬럼에  기본값이 SYSDATE (DB시스템의 현재날짜) 
CREATE TABLE SAMPLE_TRAN2 (ID NUMBER,HIREDATE DATE DEFAULT SYSDATE);
ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD';
-- TRANSACTION 시작
INSERT INTO SAMPLE_TRAN2 VALUES (100,'2015-05-22'); 
SELECT * FROM SAMPLE_TRAN2;
INSERT INTO SAMPLE_TRAN2 VALUES (100,DEFAULT);
INSERT INTO SAMPLE_TRAN2 VALUES (100,SYSDATE);
UPDATE SAMPLE_TRAN2 SET HIREDATE=DEFAULT;
ROLLBACK;  -- INSERT, UPDATE한 내용들을 취소  -- TRANSACTION 종료

-- TRUNCATE 명령 
SELECT * FROM SAMPLE_TRAN;
-- TRANSACTION 시작
DELETE FROM SAMPLE_TRAN;  -- 전체 데이타 삭제
ROLLBACK;  -- DELETE한 내용을 취소  -- TRANSACTION 종료

TRUNCATE TABLE SAMPLE_TRAN; -- 전체 데이타 삭제 (취소가 불가능) 데이타 삭제하는 속도 빠르다. 자동 COMMIT

-- SAVEPOINT 
SELECT * FROM SAMPLE_TRAN;
-- TRANSACTION 시작
INSERT INTO SAMPLE_TRAN (EMPLOYEE_ID,LAST_NAME,SALARY,DEPARTMENT_ID)
VALUES (120,'KIM',3000,30);
SAVEPOINT A;
INSERT INTO SAMPLE_TRAN 
VALUES (121,'LEE',5000,30);
SAVEPOINT B;
INSERT INTO SAMPLE_TRAN (EMPLOYEE_ID,LAST_NAME,SALARY,DEPARTMENT_ID)
VALUES (122,'PARK',7000,30);
SAVEPOINT C;
INSERT INTO SAMPLE_TRAN (EMPLOYEE_ID,LAST_NAME,SALARY,DEPARTMENT_ID)
VALUES (123,'OH',9000,30);
ROLLBACK TO SAVEPOINT B; (SAVEPOINT B로 MARKING된 부분을 기준으로 아랫부분에 작업내용 취소)
ROLLBACK TO SAVEPOINT A; (SAVEPOINT A로 MARKING된 부분을 기준으로 아랫부분에 작업내용 취소)
COMMIT; -- INSERT한 내용이 DB에 저장  -- TRANSACTION 종료

--읽기 일관성 (READ CONSISTENCY)
어떤 DB 사용자가 SELECT(데이타조회) 작업을 시작하면 데이타를 조회하기 시작한 시점의 데이타를 기준으로 조회가 끝날때까지
보게된다 

DB USER #1 
9:00 SELECT * FROM EMPLOYEES; -- 이 SELECT문장이 10분동안 진행된다고 가정   (조회종료시점  9:10)
9:07 205번 사원 데이타를 조회 -- 이 때 205 사원에 대한 급여 데이타가 4000으로 보여야 한다.
==> 9시에 시작한 QUERY(SELECT)는 QUERY가 끝날 때까지 9시 시점에 존재하는 데이타를 기준으로 조회를 하게 된다.

DB USER #2
9;05 UPDATE EMPLOYEES SET ----  변경  205번사원의 급여를 4000 => 5000 변경 
     COMMIT;

DB USER #3 
9:06 SELECT 시작 (DB USER #2가 작업한 UPDATE 결과를 조회할 수 있다.)

-- LOCK 
SELECT * FROM SAMPLE_TRAN;
INSERT INTO SAMPLE_TRAN VALUES(121,'LEE',5000,30);
COMMIT;

UPDATE SAMPLE_TRAN SET SALARY=5555 WHERE EMPLOYEE_ID=120; -- 120번 사원의 레코드에 LOCK이 걸린다. 
                                                        -- LOCK이 걸리면 지금 업데이트하고 레코드에 대해서 다른 사용자들은 
                                                        -- 변경작업(UPDATE, DELETE)을 못하게 된다.     
COMMIT;  -- LOCK이 풀린다. (ROLLBACK의 경우도 마찬가지)

-- SELECT의 FOR UPDATE 절 
SELECT * FROM SAMPLE_TRAN;  -- SELECT할때는 LOCK이 걸리지 않는다,
SELECT * FROM SAMPLE_TRAN FOR UPDATE; -- SELECT하는 레코드에 LOCK이 걸린다.
ROLLBACK; --LOCK을 풀어준다.



SELECT last_name, salary, commission_pct
FROM employees
WHERE commission_pct IS NOT NULL
ORDER BY 2 DESC, 3 DESC;

SELECT last_name, job_id, salary
FROM employees
WHERE job_id IN ('SA_REP', 'ST_CLERK')
AND salary NOT IN (2500, 3500, 7000);

SELECT last_name, job_id, salary
FROM employees
WHERE job_id IN ('SA_REP', 'ST_CLERK')
AND salary IN (2500, 3500, 7000);

SELECT INITCAP(last_name) "Name",LENGTH(last_name) "Length"
FROM employees
WHERE last_name LIKE 'J%'OR last_name LIKE 'M%' OR last_name LIKE 'A%'
ORDER BY last_name;

SELECT last_name, trunc((SYSDATE-hire_date)/7) AS TENURE
FROM employees
WHERE department_id = 90
ORDER BY TENURE DESC ;

-- 'd' format은 일요일이면 1, 월요일 2, 화요일 3,  ---
SELECT last_name, hire_date, TO_CHAR(hire_date, 'DAY'), TO_CHAR(hire_date-1, 'd') DAY
FROM employees
ORDER BY TO_CHAR(hire_date-1, 'd');


SELECT last_name, hire_date, sysdate,
(CASE WHEN months_between(sysdate,hire_date)/12 >= 15
THEN '15 years of service'
WHEN months_between(sysdate,hire_date)/12 >= 10
THEN '10 years of service'
WHEN months_between(sysdate,hire_date)/12 >= 5
THEN '5 years of service'
ELSE 'maybe next year!' END) AS "Awards"
FROM employees;


SELECT manager_id, MIN(salary)
FROM employees
WHERE manager_id IS NOT NULL
GROUP BY manager_id
HAVING MIN(salary) > 6000
ORDER BY MIN(salary) DESC;


SELECT w.last_name "Employee", w.employee_id "EMP#",
m.last_name "Manager", m.employee_id "Mgr#"
FROM employees w join employees m
ON (w.manager_id = m.employee_id);

SELECT last_name, job_id, salary
FROM employees
WHERE salary > ALL (SELECT salary
FROM employees
WHERE job_id = 'SA_MAN')
ORDER BY salary DESC;

SELECT employee_id, last_name, salary
FROM employees
WHERE department_id IN (SELECT department_id
FROM employees
WHERE last_name like '%u%')
AND salary > (SELECT AVG(salary)
FROM employees);














